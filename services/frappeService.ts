import { FrappeConfig, DocType, DocField } from '../types';

const getHeaders = (config: FrappeConfig) => ({
  'Authorization': `token ${config.apiKey}:${config.apiSecret}`,
  'Content-Type': 'application/json',
});

// Helper to clean URL
const getBaseUrl = (url: string) => url.replace(/\/$/, '');

// Helper to handle fetch errors
const handleFetchResponse = async (res: Response, context: string) => {
    if (!res.ok) {
        let errorDetails = `${res.status} ${res.statusText}`;
        try {
            const json = await res.json();
            if (json.exception) errorDetails = json.exception;
            else if (json.message) errorDetails = typeof json.message === 'object' ? JSON.stringify(json.message) : json.message;
            else if (json._server_messages) {
                 try {
                    const msgs = JSON.parse(json._server_messages);
                    errorDetails = msgs.map((m: any) => JSON.parse(m).message).join(', ');
                 } catch (e) {}
            }
        } catch (e) {
             // ignore json parse error
        }
        throw new Error(`Frappe API Error (${context}): ${errorDetails}`);
    }
    return res;
};

export const checkConnection = async (config: FrappeConfig): Promise<boolean> => {
  try {
    const res = await fetch(`${getBaseUrl(config.url)}/api/method/frappe.auth.get_logged_user`, {
      headers: getHeaders(config),
    });
    return res.ok;
  } catch (e) {
    return false;
  }
};

// 1. Get list of ALL DocTypes (names only) to let AI choose
export const fetchAllDocTypes = async (config: FrappeConfig): Promise<string[]> => {
  try {
    // Fetching standard and custom doctypes, excluding tables and singles for simplicity if needed
    const queryParams = new URLSearchParams({
      fields: JSON.stringify(["name"]),
      filters: JSON.stringify({ istable: 0, issingle: 0 }),
      limit_page_length: "5000"
    });

    const res = await fetch(`${getBaseUrl(config.url)}/api/resource/DocType?${queryParams}`, {
      headers: getHeaders(config),
    });
    
    await handleFetchResponse(res, "Fetch DocTypes");
    
    const data = await res.json();
    if (data.data) {
      return data.data.map((d: any) => d.name);
    }
    return [];
  } catch (error: any) {
    console.error("Failed to fetch doctypes", error);
    throw error;
  }
};

// 2. Get Schema (Meta) for specific DocTypes
export const fetchDocTypeSchema = async (config: FrappeConfig, docTypeName: string): Promise<DocType | null> => {
  try {
    const res = await fetch(`${getBaseUrl(config.url)}/api/resource/DocType/${docTypeName}`, {
      headers: getHeaders(config),
    });
    
    if (!res.ok) {
        // If 404, strictly return null so we skip this doctype
        if (res.status === 404) return null;
        await handleFetchResponse(res, `Schema for ${docTypeName}`);
    }
    
    const docData = await res.json();
    if (!docData.data) return null;

    const fields: DocField[] = docData.data.fields.map((f: any) => ({
      fieldname: f.fieldname,
      label: f.label,
      fieldtype: f.fieldtype,
      options: f.options
    }));

    // Add standard fields that might not be in 'fields' array
    fields.unshift(
        { fieldname: 'name', label: 'ID', fieldtype: 'Data' },
        { fieldname: 'creation', label: 'Created On', fieldtype: 'Datetime' },
        { fieldname: 'modified', label: 'Last Modified', fieldtype: 'Datetime' },
        { fieldname: 'owner', label: 'Owner', fieldtype: 'Data' }
    );

    return {
      name: docTypeName,
      fields
    };
  } catch (error) {
    console.error(`Failed to fetch schema for ${docTypeName}`, error);
    throw error; 
  }
};

// 3. Execute the Query generated by AI
export const executeFrappeQuery = async (
  config: FrappeConfig, 
  doctype: string, 
  fields: string[], 
  filters: Record<string, any> = {},
  limit: number = 100
): Promise<any[]> => {
  try {
    const postRes = await fetch(`${getBaseUrl(config.url)}/api/method/frappe.client.get_list`, {
        method: 'POST',
        headers: getHeaders(config),
        body: JSON.stringify({
            doctype,
            fields,
            filters,
            limit_page_length: limit
        })
    });

    await handleFetchResponse(postRes, `Query ${doctype}`);

    const data = await postRes.json();
    return data.message || [];
  } catch (error: any) {
    console.error("Query execution failed", error);
    throw error; // Re-throw to be caught by App.tsx
  }
};